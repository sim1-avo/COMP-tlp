terminal SEMI, COMMA, ID, INT, STRING, FLOAT, BOOL, LPAR, RPAR, COLON, PROC, CORP, VOID, IF, THEN, ELIF, FI,
ELSE, WHILE, DO, OD, READ, WRITE, ASSIGN, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND,
OR, NOT, NULL, TRUE, FALSE, INT_CONST, FLOAT_CONST, STRING_CONST, UMINUS, RETURN;

nonterminal Program, VarDeclList, ProcList, VarDecl, Type, IdListInit, Proc, ReturnExprs,
ParamDeclList, ParDecl, IdList, ResultType, ResultTypeList,

StatList, Stat, IfStat, ElifList, Elif, Else, WhileStat, ReadlnStat,
WriteStat, AssignStat, CallProc, Expr, ExprList;

precedence left AND, OR;
precedence left GT, GE,LT, LE, EQ, NE;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left DIV;
precedence left UMINUS;

/* The grammar rules */
Program ::= VarDeclList:vdList ProcList:pList         {:R= new ProgramOP(vdList, pList);:}
;
VarDeclList ::= /* empty */                {:R=null;:}
   | VarDecl:vd VarDeclList:vdList         {: ArrayList list= new ArrayList(); list.add(vd); list.addAll(vdList); R=list; :}
   ;


ProcList ::= Proc:p                 {: ArrayList list= new ArrayList(); list.add(p);:}
    |Proc:p ProcList:pList          {: ArrayList list= new ArrayList(); list.add(p); list.addAll(pList); R=list; :}
    ;

VarDecl ::= Type:t IdListInit:iListInit SEMI {:R=VarDeclOP(t,iListInit);:}
    ;
Type ::= INT        {:R= 'int';:}
        | BOOL      {:R= 'bool';:}
        | FLOAT     {:R= 'float';:}
        | STRING    {:R= 'String';:}
    ;
IdListInit ::= ID:val                                  {: R= new IdListInitOP(val);:}
   | IdListInit:iListInit COMMA ID:val                 {:ArrayList<IdListInitOP> list= iListInit; list.add(new IdListInitOP(val)); R= list; :}
   | ID:val ASSIGN Expr:e                              {: R= new IdListInitOP(val, e);:}
   | IdListInit:iListInit COMMA ID:val ASSIGN Expr:e   {:ArrayList<IdListInitOP> list= iListInit; list.add(new IdListInitOP(val, e)); R= list; :}
   ;
Proc ::= PROC ID:val LPAR ParamDeclList:pdList RPAR ResultTypeList:rtList COLON VarDeclList:vdList StatList:sList RETURN ReturnExprs:re CORP SEMI       {:R= new ProcOP(val, pdList, rtList, new ProcBodyOP( vdList, sList, re));:}
   | PROC ID:val LPAR RPAR ResultTypeList:rtList COLON VarDeclList:vdList StatList:sList RETURN ReturnExprs:re CORP SEMI                                {:R= new ProcOP(val, rtList, new ProcBodyOP( vdList, sList, re));:}
   ;
ResultTypeList ::= ResultType:rt                  {:R=rt;:}
   | ResultType:rt COMMA ResultTypeList:rtList    {: ArrayList list= new ArrayList(); list.add(rt); list.addAll(rtList); R=list; :}
    ;
ReturnExprs::=  ExprList:eList {:R=eList;:}
   | /* empty */                {:R=null;:}
    ;
ExprList ::= Expr:e                     {:R=e; :}
   | Expr:e COMMA ExprList:eList        {: ArrayList list= new ArrayList(); list.add(e); list.addAll(eList); R=list; :}
   ;

ParamDeclList ::= ParDecl:pd                    {: R=pd; :}
    | ParamDeclList:pdList SEMI ParDecl:pd      {: ArrayList list= new ArrayList(); list.addAll(pdList);  list.add(pd); R=list; :}
    ;

ParDecl ::= Type:t IdList:iList     {:R= new ParDeclOP(t, iList);:}
    ;

IdList ::= ID:val                   {:R= val;:}
    | IdList:iList COMMA ID:val     {: ArrayList list= new ArrayList();  list.addAll(iList); list.add(val); R=list; :}
    ;

ResultType ::= Type:t   {:R=t;:}
            | VOID      {:R= 'void';:}
    ;

StatList ::= Stat:s                  {: R=s; :}
        | Stat:s StatList:sList      {: ArrayList list= new ArrayList(); list.add(s); list.addAll(sList); R=list; :}
    ;

Stat ::= IfStat:is SEMI     {: R= is; :}
   | WhileStat:ws SEMI      {: R= ws; :}
   | ReadlnStat:rs SEMI     {: R= rs; :}
   | WriteStat:ws SEMI      {: R= ws; :}
   | AssignStat:as SEMI     {: R= as; :}
   | CallProc:cp SEMI       {: R= cp; :}
   ;

IfStat ::= IF Expr:e THEN StatList:sList ElifList:elList Else:el FI {: R= new IfOP(e, sList, elList, el); :}
   ;
ElifList ::= /* empty */            {:R= null;:}
   | Elif:elif ElifList:elList      {: ArrayList list= new ArrayList(); list.add(elif); if(elList != null)list.addAll(elList); R=list; :}
   ;
Elif ::= ELIF Expr:e THEN StatList:sList {: R=new ElifOP(e, sList); :}
    ;
Else ::= /* empty */          {: R= null; :}
    | ELSE StatList:sList     {: R= new ElseOP(sList); :}
   ;
WhileStat ::= WHILE StatList:sList1 RETURN Expr:e DO StatList:sList2 OD     {: R= new WhileOP(sList1,e , sList2); :}
   | WHILE Expr:e DO StatList:sList OD                      {: R= new WhileOP(e,sList); :}
   ;
ReadlnStat ::= READ LPAR IdList:ilist RPAR          {: R= new ReadOP(ilist); :}
    ;
WriteStat ::=  WRITE LPAR ExprList:elist RPAR       {: R= new WriteOP(elist); :}
;
AssignStat ::= IdList:ilist ASSIGN  ExprList:elist {:R= new AssignOP(ilist, elist);:}
    ;
CallProc ::= ID:val LPAR ExprList:elist RPAR {: R= new CallProcOP(val, elist);:}
   | ID:val LPAR RPAR       {: R= new CallProcOP(val) ;:}
   ;
Expr ::= NULL               {:R=null;:}
   | TRUE                   {:R=true;:}
   | FALSE                  {:R=false;:}
   | INT_CONST:val          {:R=val ;:}
   | FLOAT_CONST:val        {:R=val ;:}
   | STRING_CONST:val       {:R=val ;:}
   | ID:val                 {:R=val ;:}
    | CallProc:c            {: R = c;:}
   | Expr:e  PLUS Expr:ee   {: R= new PlusOP(e,ee); :}
   | Expr:e  MINUS Expr:ee  {: R= new MinusOP(e,ee); :}
   | Expr:e  TIMES Expr:ee  {: R= new TimesOP(e,ee); :}
   | Expr:e  DIV Expr:ee    {: R= new DivOP(e,ee); :}
   | Expr:e  AND Expr:ee    {: R= new AndOP(e,ee); :}
   | Expr:e  OR Expr:ee     {: R= new OrOP(e,ee); :}
   | Expr:e  GT Expr:ee     {: R= new GreaterThanOP(e,ee); :}
   | Expr:e  GE Expr:ee     {: R= new GreaterEqualsOP(e,ee); :}
   | Expr:e  LT Expr:ee     {: R= new LessThanOP(e,ee); :}
   | Expr:e  LE Expr:ee     {: R= new LessEqualsOP(e,ee); :}
   | Expr:e  EQ Expr:ee     {: R= new EqualsOP(e,ee); :}
   | Expr:e  NE Expr:ee    {: R= new NotEqualsOP(e,ee); :}
   | MINUS Expr:e     {: R=-e; :}   %prec UMINUS
   | NOT Expr:e   {: R= "!"+e; :}
    ;