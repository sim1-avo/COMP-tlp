terminal SEMI, COMMA, ID, INT, STRING, FLOAT, BOOL, LPAR, RPAR, COLON, PROC, CORP, VOID, IF, THEN, ELIF, FI,
ELSE, WHILE, DO, OD, READ, WRITE, ASSIGN, PLUS, MINUS, TIMES, DIV, EQ, NE, LT, LE, GT, GE, AND,
OR, NOT, NULL, TRUE, FALSE, INT_CONST, FLOAT_CONST, STRING_CONST, UMINUS, RETURN;

nonterminal Program, VarDeclList, ProcList, VarDecl, Type, IdListInit, Proc, ReturnExprs,
ParamDeclList, ParDecl, IdList, ResultType, ResultTypeList,

StatList, Stat, IfStat, ElifList, Elif, Else, WhileStat, ReadlnStat,
WriteStat, AssignStat, CallProc, Expr, ExprList;

precedence left AND, OR;
precedence left GT, GE,LT, LE, EQ, NE;
precedence left PLUS, MINUS;
precedence left TIMES;
precedence left DIV;
precedence left UMINUS;

/* The grammar rules */
Program ::= VarDeclList ProcList
;
VarDeclList ::= /* empty */
   | VarDecl VarDeclList
   ;

ProcList ::= ProcStatList
   | Proc ProcList
   ;
VarDecl ::= Type IdListInit SEMI
    ;
Type ::= INT
        | BOOL
        | FLOAT
        | STRING
    ;
IdListInit ::= ID
   | IdListInit COMMA ID
   | ID ASSIGN Expr
   | IdListInit COMMA ID ASSIGN Expr
   ;
Proc ::= PROC ID LPAR ParamDeclList RPAR ResultTypeList COLON
      VarDeclList StatList RETURN ReturnExprs CORP SEMI
   | PROC ID LPAR RPAR ResultTypeList COLON
      VarDeclList StatList RETURN ReturnExprs CORP SEMI
   ;
ResultTypeList ::= ResultType
   | ResultType COMMA ResultTypeList
    ;
ReturnExprs::=  ExprList
   | /* empty */
    ;
ExprList ::= Expr:e {:R=e; :}
   | Expr COMMA ExprList
   ;

ParamDeclList ::= ParDecl | ParamDeclList SEMI ParDecl
    ;

ParDecl ::= Type IdList
    ;

IdList ::= ID | IdList COMMA ID
    ;

ResultType ::= Type | VOID
    ;

StatList ::= Stat:s                  {: R=s; :}
        | Stat:s StatList:sList      {: ArrayList list= new ArrayList(); list.add(s); list.addAll(sList); R=list; :}
    ;

Stat ::= IfStat:is SEMI     {: R= is; :}
   | WhileStat:ws SEMI      {: R= ws; :}
   | ReadlnStat:rs SEMI     {: R= rs; :}
   | WriteStat:ws SEMI      {: R= ws; :}
   | AssignStat:as SEMI     {: R= as; :}
   | CallProc:cp SEMI       {: R= cp; :}
   ;

IfStat ::= IF Expr:e THEN StatList:sList ElifList:elList Else:el FI {: R= new IfOP(e, sList, elList, el); :}
   ;
ElifList ::= /* empty */            {:R= null;:}
   | Elif:elif ElifList:elList      {: ArrayList list= new ArrayList(); list.add(elif); if(elList != null)list.addAll(elList); R=list; :}
   ;
Elif ::= ELIF Expr:e THEN StatList:sList {: R=new ElifOP(e, sList); :}
    ;
Else ::= /* empty */          {: R= null; :}
    | ELSE StatList:sList     {: R= new ElseOP(sList); :}
   ;
WhileStat ::= WHILE StatList:sList1 RETURN Expr:e DO StatList:sList2 OD     {: R= new WhileOP(sList1,e , sList2); :}
   | WHILE Expr:e DO StatList:sList OD                      {: R= new WhileOP(e,sList); :}
   ;
ReadlnStat ::= READ LPAR IdList:ilist RPAR          {: R= new ReadOP(ilist); :}
    ;
WriteStat ::=  WRITE LPAR ExprList:elist RPAR       {: R= new WriteOP(elist); :}
;
AssignStat ::= IdList:ilist ASSIGN  ExprList:elist {:R= new AssignOP(ilist, elist);:}
    ;
CallProc ::= ID:val LPAR ExprList:elist RPAR {: R= new CallProcOP(val, elist);:}
   | ID:val LPAR RPAR       {: R= new CallProcOP(val) ;:}
   ;
Expr ::= NULL               {:R=null;:}
   | TRUE                   {:R=true;:}
   | FALSE                  {:R=false;:}
   | INT_CONST:val          {:R=val ;:}
   | FLOAT_CONST:val        {:R=val ;:}
   | STRING_CONST:val       {:R=val ;:}
   | ID:val                 {:R=val ;:}
    | CallProc:c            {: R = c;:}
   | Expr:e  PLUS Expr:ee   {: R= new PlusOP(e,ee); :}
   | Expr:e  MINUS Expr:ee  {: R= new MinusOP(e,ee); :}
   | Expr:e  TIMES Expr:ee  {: R= new TimesOP(e,ee); :}
   | Expr:e  DIV Expr:ee    {: R= new DivOP(e,ee); :}
   | Expr:e  AND Expr:ee    {: R= new AndOP(e,ee); :}
   | Expr:e  OR Expr:ee     {: R= new OrOP(e,ee); :}
   | Expr:e  GT Expr:ee     {: R= new GreaterThanOP(e,ee); :}
   | Expr:e  GE Expr:ee     {: R= new GreaterEqualsOP(e,ee); :}
   | Expr:e  LT Expr:ee     {: R= new LessThanOP(e,ee); :}
   | Expr:e  LE Expr:ee     {: R= new LessEqualsOP(e,ee); :}
   | Expr:e  EQ Expr:ee     {: R= new EqualsOP(e,ee); :}
   | Expr:e  NE Expr:ee    {: R= new NotEqualsOP(e,ee); :}
   | MINUS Expr:e     {: R=-e; :}   %prec UMINUS
   | NOT Expr:e   {: R= "!"+e; :}
    ;